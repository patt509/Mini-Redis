CC = gcc
# MMD generates .d files with dependencies of the corresponding .o file
# MP avoids errors when an .h file gets 
# -I include and -I tests look for header files in the 'include'
# and the 'tests' folders
CFLAGS = -Wall -Wextra -Werror -g -MMD -MP -I include -I tests

# Directories
SRC_DIR = src
TEST_DIR = tests
BUILD_DIR = build

# Source Files
# Find all .c files in src/
SRCS = $(wildcard $(SRC_DIR)/*.c)
# Find all .c files in tests/
TEST_SRCS = $(wildcard $(TEST_DIR)/*.c)

# Object files
OBJS = $(SRCS:$(SRC_DIR)/%.c=$(BUILD_DIR)/%.o)
TEST_OBJS = $(TEST_SRCS:$(TEST_DIR)/%.c=$(BUILD_DIR)/%.o)

# Exclude server.o (main) from test build to avoid multiple definition
# of main (I will probably implement server.c after testing appropriately
# all the hash table functions)
OBJS_NO_MAIN = $(filter-out $(BUILD_DIR)/server.o $(BUILD_DIR)/main.o, $(OBJS))

# Executable Names
TARGET = mini-redis
TEST_TARGET = $(BUILD_DIR)/run_tests

# --- RULES ---

.PHONY: all clean tests run_tests

# Default target: build the main program
all: $(TARGET)

# Build the main executable (commented out until i implement main.c (in src))
# $(TARGET): $(OBJS)
#		$(CC) $(OBJS) -o $@

# Build the test executable
# Links test objects + src objects (excluding main)
tests: $(TEST_TARGET)

$(TEST_TARGET): $(OBJS_NO_MAIN) $(TEST_OBJS)
	$(CC) $(OBJS_NO_MAIN) $(TEST_OBJS) -o $@

# Compile source files
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Compile test files
$(BUILD_DIR)/%.o: $(TEST_DIR)/%.c
	@mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Run the tests
run_tests: $(TEST_TARGET)
	./$(TEST_TARGET)

# Clean build artifacts
clean:
	rm -rf $(BUILD_DIR) $(TARGET)

# Include dependencies generated by -MMD
-include $(OBJS:.o=.d)
-include $(TEST_OBJS:.o=.d)